---
title: Sistema de ComunicaÃ§Ã£o por WebSockets
description: Sistema responsÃ¡vel pela comunicaÃ§Ã£o em tempo real entre robÃ´, backend e frontend do projeto Tour Inteli, incluindo chat com visitantes e controle de checkpoints.
---

## **1. IntroduÃ§Ã£o**

&emsp;Este documento descreve a arquitetura, os componentes e os fluxos do sistema de comunicaÃ§Ã£o em tempo real do robÃ´ do Inteli.
O sistema de WebSockets possui dois mÃ³dulos principais:

### **1.1 MÃ³dulo de Chat e ConversaÃ§Ã£o**

- Recebe perguntas dos visitantes (texto ou Ã¡udio)
- Envia respostas em texto e Ã¡udio
- Sincroniza mÃºltiplos dispositivos (painel do operador, robÃ´, turista)
- Realiza transcriÃ§Ã£o de fala (STT) e sÃ­ntese de voz (TTS)

### **1.2 MÃ³dulo de Controle de Checkpoints**

- Comunica eventos de navegaÃ§Ã£o do robÃ´ (inÃ­cio/fim de checkpoints)
- Sincroniza status do robÃ´ em tempo real com o backend e frontend
- Atualiza automaticamente o banco de dados com timestamps reais
- Gerencia comandos de controle (play, stop, status)

&emsp;A comunicaÃ§Ã£o ocorre em tempo real via WebSockets, centralizada pelo backend implementado em Rust com Actix-Web.

## **2. VisÃ£o Geral da Arquitetura**

&emsp;O sistema utiliza trÃªs canais de WebSockets:

- **Text WebSocket** â†’ para mensagens em texto (chat)
- **Audio WebSocket** â†’ para mensagens de Ã¡udio (entrada e saÃ­da do chat)
- **Robot WebSocket** â†’ para controle de checkpoints e sincronizaÃ§Ã£o de navegaÃ§Ã£o

### **Diagrama da Arquitetura Completa**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         FRONTEND (React/JS)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Text WebSocket  â”‚   â”‚ Audio WebSocket  â”‚   â”‚ Robot WebSocket â”‚  â”‚
â”‚  â”‚  (Chat)          â”‚   â”‚  (Chat)          â”‚   â”‚ (Checkpoints)   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                      â”‚                       â”‚
            â–¼                      â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      BACKEND (Actix-Web + Rust)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              Broadcast Server (Central Hub - Chat)             â”‚  â”‚
â”‚  â”‚  - ConexÃµes de texto e Ã¡udio                                   â”‚  â”‚
â”‚  â”‚  - Broadcast de mensagens                                      â”‚  â”‚
â”‚  â”‚  - ConversÃ£o Textoâ†’Ãudio (TTS)                                 â”‚  â”‚
â”‚  â”‚  - ExclusÃ£o de eco por cliente                                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚         Robot Client + Frontend Server (Checkpoints)           â”‚  â”‚
â”‚  â”‚  - Cliente WebSocket â†’ Conecta ao servidor Python do robÃ´      â”‚  â”‚
â”‚  â”‚  - Servidor WebSocket â†’ Aceita conexÃµes do frontend            â”‚  â”‚
â”‚  â”‚  - Relay inteligente de eventos e comandos                     â”‚  â”‚
â”‚  â”‚  - AtualizaÃ§Ã£o automÃ¡tica do banco de dados (PostgreSQL)       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚        â–²                                             â”‚                â”‚
â”‚        â”‚ WebSocket Client                            â”‚ Broadcast      â”‚
â”‚        â”‚ (tokio-tungstenite)                         â”‚ (actix-ws)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                                             â”‚
         â–¼                                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ROBOT (Python + aiohttp)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              WebSocket Server (move_path.py)                   â”‚  â”‚
â”‚  â”‚  - Recebe comandos do backend (play, stop, get_status)         â”‚  â”‚
â”‚  â”‚  - Envia eventos de checkpoint em tempo real                   â”‚  â”‚
â”‚  â”‚  - Controla movimento fÃ­sico do robÃ´ via WebRTC               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²
         â”‚ WebRTC (movimento fÃ­sico)
         â–¼
    ğŸ¤– RobÃ´ FÃ­sico
```

## **3. Componentes Principais**

### **MÃ“DULO 1: CHAT E CONVERSAÃ‡ÃƒO**

## **3.1 Broadcast Server (`broadcast.rs`)**

### **O que Ã©?**

&emsp;O _Broadcast Server_ Ã© o "cÃ©rebro" do sistema de comunicaÃ§Ã£o de chat.
Ele funciona como um **ponto central** que recebe mensagens e distribui para todos os clientes conectados.

### **O que ele faz?**

- **Gerencia clientes conectados**
  - Clientes de texto
  - Clientes de Ã¡udio

- **Distribui mensagens**
  - Texto â†’ todos clientes de texto
  - Ãudio â†’ todos clientes de Ã¡udio

- **Converte texto em Ã¡udio**
  - Usando o serviÃ§o ML de TTS, quando necessÃ¡rio

- **Evita eco**
  - O cliente que enviou a mensagem nÃ£o recebe sua prÃ³pria mensagem (evitando duplicaÃ§Ã£o).

### **Estrutura interna (simplificada)**

```rust
pub struct BroadcastServer {
    text_clients: HashMap<String, Recipient<BroadcastMessage>>,
    audio_clients: HashMap<String, Recipient<BroadcastAudio>>,
    ml_endpoint: String,
}
```

### **Mensagens que ele entende**

| Mensagem                | Significado                         |
| ----------------------- | ----------------------------------- |
| `Connect`               | Cliente de texto entrou             |
| `ConnectAudio`          | Cliente de Ã¡udio entrou             |
| `Disconnect`            | Cliente saiu                        |
| `Broadcast`             | Enviar texto para todos             |
| `BroadcastAudioMessage` | Enviar Ã¡udio para todos             |
| `RequestTTS`            | Transformar texto em Ã¡udio e enviar |

## **3.2 Text WebSocket Handler (`text_ws.rs`)**

### **O que Ã©?**

&emsp;Ã‰ o componente responsÃ¡vel por lidar com mensagens de texto enviadas pelos clientes.

### **O que ele faz?**

1. TextWebSocket recebe uma mensagem de texto do cliente.
2. Envia essa mensagem para o endpoint `/v1/modelo`.
3. Recebe a resposta do modelo.
4. Retorna a resposta ao cliente.
5. Envia essa mesma resposta para conversÃ£o TTS (para que os clientes de Ã¡udio tambÃ©m a recebam).
6. Usa o Broadcast Server para sincronizar a resposta com todos os dispositivos.

### **Exemplo de mensagem enviada pelo cliente**

```json
{
  "type": "text",
  "texto": "Qual Ã© a histÃ³ria deste lugar?",
  "checkpoint_id": 123,
  "estado": "active",
  "question_topic": "histÃ³ria",
  "tour_id": 456
}
```

### **Exemplo de resposta**

```json
{
  "texto": "Este lugar tem uma histÃ³ria fascinante...",
  "message_type": "resposta"
}
```

## **3.3 Audio WebSocket Handler (`audio_ws.rs`)**

### **O que Ã©?**

&emsp;Esse componente recebe Ã¡udios dos usuÃ¡rios, realiza transcriÃ§Ã£o (STT), envia texto para o modelo e depois converte a resposta em Ã¡udio (TTS).

### **Fluxo 1: UsuÃ¡rio fala (STT)**

```
Cliente envia Ã¡udio (base64)
â†’ AudioWebSocket decodifica Ã¡udio
â†’ STT transcreve para texto
â†’ Modelo recebe texto
â†’ Modelo retorna resposta
â†’ TTS converte resposta em Ã¡udio
â†’ Texto e Ã¡udio retornam ao cliente
â†’ Broadcast para outros clientes
```

### **Fluxo 2: UsuÃ¡rio envia texto pelo Audio WS**

```
Cliente envia texto
â†’ Modelo retorna resposta
â†’ TTS converte resposta em Ã¡udio
â†’ Sistema envia texto e Ã¡udio ao cliente
â†’ Broadcast para todos os clientes
```

## **3.4 Modelo Endpoint (`modelo.rs`)**

### **O que Ã©?**

&emsp;Um endpoint HTTP usado para enviar perguntas ao modelo de IA responsÃ¡vel por gerar respostas.

### **O que ele faz?**

- Recebe uma pergunta via POST
- Salva a pergunta no banco.
- Envia para o modelo externo.
- Salva a resposta no banco.
- Atualiza o estado da pergunta.
- Retorna a resposta ao WebSocket.

### **Endpoint**

```
POST /v1/modelo
```

---

### **MÃ“DULO 2: CONTROLE DE CHECKPOINTS**

## **3.5 Robot Client (`robot_client.rs`)**

### **O que Ã©?**

&emsp;Cliente WebSocket que conecta ao servidor Python do robÃ´ para receber eventos de navegaÃ§Ã£o e enviar comandos de controle.

### **O que ele faz?**

- **Conecta ao robÃ´** via WebSocket (tokio-tungstenite)
- **Recebe eventos do robÃ´** (checkpoint_started, checkpoint_completed, emergency_stop)
- **Envia comandos** (play, stop, get_status)
- **Atualiza o banco de dados** automaticamente com timestamps reais
- **Retenta conexÃ£o** a cada 5 segundos se o robÃ´ estiver offline
- **Broadcast para frontend** via canal broadcast

### **Estrutura interna**

```rust
pub struct RobotClient {
    robot_ip: String,
    writer: Arc<Mutex<Option<WsWriter>>>,
    frontend_tx: broadcast::Sender<FrontendEvent>,
    db_pool: PgPool,
}
```

### **Eventos recebidos do robÃ´**

| Evento                 | Quando ocorre                         | AÃ§Ã£o no Backend                                     |
| ---------------------- | ------------------------------------- | --------------------------------------------------- |
| `connected`            | ConexÃ£o inicial estabelecida          | Envia status inicial para frontend                  |
| `checkpoint_started`   | RobÃ´ inicia movimento para checkpoint | UPDATE banco: `status='running', inicio_real=NOW()` |
| `checkpoint_completed` | RobÃ´ chega no checkpoint              | UPDATE banco: `status='finished', fim_real=NOW()`   |
| `emergency_stop`       | Parada de emergÃªncia acionada         | UPDATE banco: `status='skipped'` (checkpoint atual) |
| `robot_connected`      | RobÃ´ fÃ­sico conecta via WebRTC        | Notifica frontend que robÃ´ estÃ¡ online              |

### **Comandos enviados ao robÃ´**

```rust
RobotCommand::play()        // Executar prÃ³ximo checkpoint
RobotCommand::stop()        // Parada de emergÃªncia
RobotCommand::get_status()  // Consultar status atual
```

### **Exemplo de atualizaÃ§Ã£o no banco**

```rust
// Quando checkpoint inicia
sqlx::query(
    "UPDATE checkpoints
     SET status = $1, inicio_real = $2
     WHERE tipo = $3 AND ordem = $4"
)
.bind("running")
.bind(inicio_dt)
.bind(&tipo)
.bind(ordem)
.execute(db_pool)
.await?;

// Quando checkpoint completa
sqlx::query(
    "UPDATE checkpoints
     SET status = $1, fim_real = $2
     WHERE tipo = $3 AND ordem = $4"
)
.bind("finished")
.bind(fim_dt)
.bind(&tipo)
.bind(ordem)
.execute(db_pool)
.await?;
```

## **3.6 Frontend Server (`frontend_server.rs`)**

### **O que Ã©?**

&emsp;Servidor WebSocket que aceita conexÃµes do frontend para enviar eventos de checkpoint em tempo real e receber comandos de controle.

### **O que ele faz?**

- **Aceita conexÃµes WebSocket** do frontend (actix-ws)
- **Relata eventos do robÃ´** para o frontend em tempo real
- **Recebe comandos do frontend** (play, stop, status)
- **Encaminha comandos** para o RobotClient
- **Usa tokio::select!** para gerenciar fluxo bidirecional

### **Handler principal**

```rust
pub async fn ws_frontend_handler(
    req: HttpRequest,
    stream: web::Payload,
    app_state: web::Data<AppState>,
) -> Result<HttpResponse, Error>
```

### **Fluxo bidirecional**

```rust
tokio::select! {
    // Recebe eventos do robÃ´ â†’ Envia para frontend
    Ok(event) = frontend_rx.recv() => {
        session.text(json).await?;
    }

    // Recebe comandos do frontend â†’ Envia para robÃ´
    Some(Ok(msg)) = msg_stream.next() => {
        let cmd = serde_json::from_str::<FrontendCommand>(&text)?;
        robot_client.send_command(cmd).await?;
    }
}
```

## **3.7 WebSocket Models (`websocket.rs`)**

### **Estruturas de dados**

#### **RobotEvent** (RobÃ´ â†’ Backend)

```rust
pub enum RobotEvent {
    Connected { status: RobotStatus },
    CheckpointStarted { tipo: String, ordem: i32, status: String, inicio_real: String },
    CheckpointCompleted { tipo: String, ordem: i32, status: String, inicio_real: String, fim_real: String },
    EmergencyStop { tipo: Option<String>, ordem: Option<i32> },
    RobotConnected { status: String },
}
```

#### **FrontendEvent** (Backend â†’ Frontend)

```rust
pub enum FrontendEvent {
    RobotStatus { robot_connected: bool, is_running: bool, current_checkpoint: Option<String> },
    CheckpointStarted { tipo: String, ordem: i32, status: String, inicio_real: DateTime<Utc> },
    CheckpointCompleted { tipo: String, ordem: i32, status: String, inicio_real: DateTime<Utc>, fim_real: DateTime<Utc> },
    EmergencyStop { tipo: Option<String>, ordem: Option<i32> },
    Error { message: String },
}
```

#### **FrontendCommand** (Frontend â†’ Backend)

```rust
pub enum FrontendCommand {
    Play,
    Stop,
    GetStatus,
}
```

## **4. Fluxos de ComunicaÃ§Ã£o**

### **4.1 Fluxo de Checkpoint Completo**

```
1. Frontend envia comando
   Frontend â†’ Backend: { "command": "play" }

2. Backend encaminha para robÃ´
   Backend (RobotClient) â†’ Robot Server: { "action": "play" }

3. RobÃ´ inicia movimento
   Robot Server â†’ Backend: { "event": "checkpoint_started", "tipo": "recepcao", "ordem": 1, ... }

4. Backend atualiza banco de dados
   UPDATE checkpoints SET status='running', inicio_real='2025-12-15T14:02:35Z' WHERE tipo='recepcao'

5. Backend relata para frontend
   Backend â†’ Frontend: { "event": "checkpoint_started", "tipo": "recepcao", ... }

6. Frontend atualiza UI
   UI mostra: "ğŸš€ Indo para RecepÃ§Ã£o..."
   Perguntas bloqueadas atÃ© chegada

7. RobÃ´ chega no destino
   Robot Server â†’ Backend: { "event": "checkpoint_completed", "tipo": "recepcao", "fim_real": "..." }

8. Backend atualiza banco
   UPDATE checkpoints SET status='finished', fim_real='2025-12-15T14:08:12Z' WHERE tipo='recepcao'

9. Backend relata para frontend
   Backend â†’ Frontend: { "event": "checkpoint_completed", "tipo": "recepcao", ... }

10. Frontend libera perguntas
    UI mostra: "âœ… Chegou na RecepÃ§Ã£o! FaÃ§a suas perguntas"
    Perguntas do checkpoint 'recepcao' liberadas
```

### **4.2 Fluxo de Parada de EmergÃªncia**

```
1. Frontend envia stop
   Frontend â†’ Backend: { "command": "stop" }

2. Backend encaminha
   Backend â†’ Robot: { "action": "stop" }

3. RobÃ´ para imediatamente
   Robot Server â†’ Backend: { "event": "emergency_stop", "tipo": "auditorio", "ordem": 2 }

4. Backend atualiza banco
   UPDATE checkpoints SET status='skipped' WHERE tipo='auditorio' AND status='running'

5. Backend notifica frontend
   Backend â†’ Frontend: { "event": "emergency_stop", "tipo": "auditorio" }

6. Frontend mostra alerta
   UI: "ğŸ›‘ Tour interrompido! Checkpoint 'AuditÃ³rio' foi pulado"
```

### **4.3 SincronizaÃ§Ã£o Entre Clientes (Chat)**

&emsp;O sistema implementa um padrÃ£o publish-subscribe atravÃ©s do `BroadcastServer`:

1. **Clientes de Texto** recebem:
   - Perguntas de outros usuÃ¡rios
   - Respostas do modelo (tanto de clientes de texto quanto de Ã¡udio)

2. **Clientes de Ãudio** recebem:
   - Ãudio das respostas (convertidas via TTS)

3. **ExclusÃ£o de Eco:**
   - Cada mensagem broadcast pode especificar um `exclude_client`
   - O cliente que originou a mensagem nÃ£o recebe seu prÃ³prio broadcast
   - Evita feedback loops e duplicaÃ§Ã£o de mensagens

## **5. IntegraÃ§Ã£o com Banco de Dados**

### **Tabela: checkpoints**

| Coluna            | Tipo        | Preenchimento                                         |
| ----------------- | ----------- | ----------------------------------------------------- |
| `id`              | SERIAL (PK) | Auto-gerado                                           |
| `tour_id`         | INT (FK)    | CriaÃ§Ã£o do tour                                       |
| `tipo`            | TEXT        | CriaÃ§Ã£o do tour (recepcao, auditorio, atelie, etc.)   |
| `ordem`           | INT         | CriaÃ§Ã£o do tour (1, 2, 3, 4, 5)                       |
| `status`          | TEXT        | Inicial: `pending` â†’ `running` â†’ `finished`/`skipped` |
| `inicio_previsto` | TIMESTAMPTZ | CriaÃ§Ã£o do tour (horÃ¡rio estimado)                    |
| `inicio_real`     | TIMESTAMPTZ | **Evento `checkpoint_started`** (timestamp real)      |
| `fim_real`        | TIMESTAMPTZ | **Evento `checkpoint_completed`** (timestamp real)    |

### **Estados do checkpoint**

| Status     | Quando ocorre                          |
| ---------- | -------------------------------------- |
| `pending`  | Checkpoint criado, aguardando execuÃ§Ã£o |
| `running`  | RobÃ´ em movimento para o checkpoint    |
| `finished` | RobÃ´ chegou e completou o checkpoint   |
| `skipped`  | Emergency stop durante execuÃ§Ã£o        |

## **6. Formatos de Mensagens**

### **6.1 Chat - Broadcast de texto**

```json
{
  "message_type": "broadcast_text",
  "texto": "Resposta do modelo..."
}
```

### **6.2 Chat - Broadcast de Ã¡udio**

```json
{
  "message_type": "broadcast_audio",
  "audio_base64": "AAAAFJDSAIWEA..."
}
```

### **6.3 Checkpoints - Evento de inÃ­cio**

```json
{
  "event": "checkpoint_started",
  "tipo": "recepcao",
  "ordem": 1,
  "status": "running",
  "inicio_real": "2025-12-15T14:02:35.123Z"
}
```

### **6.4 Checkpoints - Evento de conclusÃ£o**

```json
{
  "event": "checkpoint_completed",
  "tipo": "recepcao",
  "ordem": 1,
  "status": "finished",
  "inicio_real": "2025-12-15T14:02:35.123Z",
  "fim_real": "2025-12-15T14:08:12.456Z"
}
```

### **6.5 Checkpoints - Status do robÃ´**

```json
{
  "event": "robot_status",
  "robot_connected": true,
  "is_running": false,
  "current_checkpoint": "recepcao"
}
```

## **7. ConfiguraÃ§Ã£o**

### **7.1 Arquivo config.toml**

```toml
[settings.server]
host = "0.0.0.0"
port = 8081  # Backend Rust

[settings.database]
host = "aws-1-us-east-2.pooler.supabase.com"
username = "postgres.xxxxx"
password = "xxxxx"
database = "postgres"
port = 5432
max_connections = 5

[settings.robot]
ip = "127.0.0.1"  # IP do servidor Python do robÃ´ (localhost para testes)
```

### **7.2 Portas utilizadas**

| ServiÃ§o               | Porta | Protocolo |
| --------------------- | ----- | --------- |
| Backend Rust          | 8081  | HTTP/WS   |
| Robot Python Server   | 8080  | HTTP/WS   |
| PostgreSQL (Supabase) | 5432  | TCP       |

## **8. Testando o Sistema**

### **8.1 Teste de Checkpoints**

```powershell
# Terminal 1: Servidor Python do robÃ´
cd 2025-2B-T12-EC08-ROBO
python move_path.py

# Terminal 2: Backend Rust
cd 2025-2B-T12-EC08-BACK
cargo run -- --config config.toml

# Terminal 3: Cliente de teste
cd 2025-2B-T12-EC08-BACK
python test_websocket.py interactive --url ws://localhost:8081/ws
```

**Comandos disponÃ­veis:**

- `status` - Consultar status do robÃ´
- `play` - Executar prÃ³ximo checkpoint
- `stop` - Parada de emergÃªncia
- `quit` - Sair

### **8.2 Observando logs**

**Backend logs esperados:**

```
âœ… Conectado ao robÃ´!
ğŸ“¡ Iniciando listener de eventos do robÃ´
ğŸ¤– Status inicial do robÃ´: robot_connected=false
â–¶ï¸ Checkpoint INICIADO: recepcao (ordem: 1)
ğŸ’¾ Checkpoint atualizado no banco: recepcao -> running
âœ… Checkpoint CONCLUÃDO: recepcao (status: finished)
ğŸ’¾ Checkpoint finalizado no banco: recepcao -> finished
```

## **9. Tratamento de Erros**

### **9.1 RobÃ´ offline**

- **Comportamento:** Backend retenta conexÃ£o a cada 5 segundos
- **Frontend:** Recebe `robot_connected: false` no status
- **Comandos:** SÃ£o enfileirados mas nÃ£o executados atÃ© robÃ´ conectar

### **9.2 Perda de conexÃ£o durante execuÃ§Ã£o**

- **WebSocket desconecta:** Backend retenta automaticamente
- **Checkpoint em andamento:** Status `running` permanece no banco atÃ© reconexÃ£o
- **Frontend:** Mostra indicador de "ConexÃ£o perdida"

### **9.3 Emergency stop**

- **Checkpoint atual:** Marcado como `skipped`
- **Checkpoints futuros:** Permanecem `pending`
- **RobÃ´:** Para movimento fÃ­sico imediatamente

## **10. ConclusÃ£o**

O sistema de WebSockets deste projeto Ã© o que permite:

### **MÃ³dulo de Chat:**

- ConversaÃ§Ã£o natural com visitantes via texto e Ã¡udio
- SincronizaÃ§Ã£o em tempo real entre mÃºltiplos dispositivos
- IntegraÃ§Ã£o inteligente com STT, TTS e modelo de IA

### **MÃ³dulo de Checkpoints:**

- Controle preciso da navegaÃ§Ã£o do robÃ´
- AtualizaÃ§Ã£o automÃ¡tica do banco com timestamps reais
- SincronizaÃ§Ã£o perfeita entre robÃ´ fÃ­sico, backend e frontend
- Gerenciamento de estados e paradas de emergÃªncia

A arquitetura foi construÃ­da para ser:

- **Simples de entender** - Componentes bem separados e documentados
- **EscalÃ¡vel** - Usa broadcast channels e WebSockets eficientes
- **Resiliente** - Retry automÃ¡tico e tratamento de erros
- **ExtensÃ­vel** - FÃ¡cil adicionar novos eventos e comandos
- **TestÃ¡vel** - Cliente de teste incluso para validaÃ§Ã£o

O sistema estÃ¡ pronto para uso em produÃ§Ã£o, com o robÃ´ fÃ­sico ou em modo de simulaÃ§Ã£o para testes.
